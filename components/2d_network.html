<svg id="network"></svg>

<div class="view_controls">
  <button type="button" id="toggle_2d_network_settings" class="btn btn-light btn-sm" data-toggle="button" title="Network Settings">
    <span class="oi oi-cog"></span>
  </button>
  <button type="button" class="btn btn-light btn-sm"  data-toggle="modal" data-target="#export_svg_modal" title="Export Network">
    <span class="oi oi-data-transfer-download"></span>
  </button>
  <button id="fitbutton" type="button" class="btn btn-light btn-sm" title="Center and Scale Network">
    <span class="oi oi-target"></span>
  </button>
  <button id="pinbutton" type="button" class="btn btn-light btn-sm" data-toggle="button" aria-pressed="false" autocomplete="off" title="Pin all Nodes">
    <span class="oi oi-pin"></span>
  </button>
</div>

<div id="network_settings_pane" class="left_pane">
  <ul class="nav nav-tabs" role="tablist">
    <li class="nav-item">
      <a class="nav-link active" id="nodes-tab" data-toggle="tab" href="#node_settings" role="tab" aria-controls="node_settings" aria-selected="true">Nodes</a>
    </li>
    <li class="nav-item">
      <a class="nav-link" id="links-tab" data-toggle="tab" href="#link_settings" role="tab" aria-controls="link_settings" aria-selected="false">Links</a>
    </li>
    <li class="nav-item">
      <a class="nav-link" id="network-tab" data-toggle="tab" href="#network_settings" role="tab" aria-controls="network_settings" aria-selected="false">Network</a>
    </li>
  </ul>
  <div class="tab-content">
    <div class="tab-pane fade show active" id="node_settings" role="tabpanel" aria-labelledby="nodes-tab">
      <div class="form-group row">
        <div class="col-4"><label for="node-label-variable" data-toggle="tooltip" title="What field should be displayed as a label for the node?">Label</label></div>
        <div class="col-8"><select id="node-label-variable" class="custom-select custom-select-sm nodeVariables"><option>None</option></select></div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label for="node-tooltip-variable" data-toggle="tooltip" title="What node data should be displayed as a tooltip for the node?">Tooltip</label></div>
        <div class="col-8"><select id="node-tooltip-variable" class="custom-select custom-select-sm nodeVariables"><option>None</option></select></div>
      </div>
      <div class="form-group row">
        <div class="col-4">Color</div>
        <div class="col-8"><button class="btn btn-sm btn-secondary w-100 launch-color-options">Color Options</button></div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label for="node-symbol-variable" data-toggle="tooltip" title="What shape should the nodes be?">Shape By</label></div>
        <div class="col-8"><select id="node-symbol-variable" class="custom-select custom-select-sm nodeVariables"><option>None</option></select></div>
      </div>
      <div id="node_shape_value_row" class="form-group row">
        <div class="col-4"><label for="node-symbol" data-toggle="tooltip" title="What shape should the nodes be?">Shape</label></div>
        <div class="col-8"><select id="node-symbol" class="custom-select custom-select-sm">
          <option value="symbolCircle" selected>&nbsp;&#11044; (Circle)</option>
          <option value="symbolTriangle">&nbsp;&#9650; (Up Triangle)</option>
          <option value="symbolTriangleDown">&nbsp;&#9660; (Down Triangle)</option>
          <option value="symbolTriangleLeft">&nbsp;&#9664; (Left Triangle)</option>
          <option value="symbolTriangleRight">&nbsp;&#9654; (Right Triangle)</option>
          <option value="symbolDiamond">&nbsp;&#10731; (Vertical Diamond)</option>
          <option value="symbolDiamondAlt">&nbsp;&#10731; (Horizontal Diamond)</option>
          <option value="symbolSquare">&nbsp;&#9632; (Square)</option>
          <option value="symbolDiamondSquare">&nbsp;&#9670; (Tilted Square)</option>
          <option value="symbolPentagon">&nbsp;&#11039; (Pentagon)</option>
          <option value="symbolHexagon">&nbsp;&#11042; (Hexagon)</option>
          <option value="symbolHexagonAlt">&nbsp;&#11043; (Tilted Hexagon)</option>
          <option value="symbolOctagon">&nbsp;&#11204; (Octagon)</option>
          <option value="symbolOctagonAlt">&nbsp;&#11203; (Tilted Octagon)</option>
          <option value="symbolCross">&nbsp;&#10010; (Addition Sign)</option>
          <option value="symbolX">&nbsp;&#10006; (Multiplication Sign)</option>
          <option value="symbolWye">&nbsp;&#120300; (Wye)</option>
          <option value="symbolStar">&nbsp;&#9733; (Star)</option>
        </select></div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label for="node-radius-variable" data-toggle="tooltip" title="How large should the nodes be?">Size By</label></div>
        <div class="col-8"><select id="node-radius-variable" class="custom-select custom-select-sm nodeVariables numeric"><option>None</option></select></div>
      </div>
      <div id="node_size_value_row" class="form-group row">
        <div class="col-4"><label for="node-radius" data-toggle="tooltip" title="How large should the nodes be?">Size</label></div>
        <div class="col-8"><input type="range" id="node-radius" min="100" value="250" step="1" max="5000" /></div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label for="highlight-neighbors" data-toggle="tooltip" title="Should MicrobeTrace Highlight a node's neighbors when you hover on it?">Neighbors</label></div>
        <div class="col-8">
          <div class="btn-group btn-group-toggle btn-group-sm" data-toggle="buttons">
            <label class="btn btn-secondary active">
              <input type="radio" name="HighlightOptions" id="dont-highlight-neighbors" autocomplete="off" checked> Normal
            </label>
            <label class="btn btn-secondary">
              <input type="radio" name="HighlightOptions" id="highlight-neighbors" autocomplete="off"> Highlighted
            </label>
          </div>
        </div>
      </div>
    </div>
    <div class="tab-pane fade" id="link_settings" role="tabpanel" aria-labelledby="links-tab">
      <div class="form-group row">
        <div class="col-4"><label for="link-tooltip-variable" data-toggle="tooltip" title="What data should be displayed when you hover over a link?">Tooltip</label></div>
        <div class="col-8"><select id="link-tooltip-variable" class="custom-select custom-select-sm linkVariables"><option>None</option></select></div>
      </div>
      <div class="form-group row">
        <div class="col-4">Color</div>
        <div class="col-8"><button class="btn btn-sm btn-secondary w-100 launch-color-options">Color Options</button></div>
      </div>
      <div id="link-transparency-row" class="form-group row">
        <div class="col-4"><label data-toggle="tooltip" title="How transparent should the links be?">Transparency</label></div>
        <div class="col-8"><input type="range" id="link-opacity" min="0" max="1" value="0" step="0.01" /></div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label for="link-width-variable" data-toggle="tooltip" title="How thick should the links be?">Width By</label></div>
        <div class="col-8"><select id="link-width-variable" class="custom-select custom-select-sm linkVariables"><option>None</option></select></div>
      </div>
      <div id="link-reciprocalthickness-row" class="form-group row">
        <div class="col-4"><label data-toggle="tooltip" title="Should link widths be proportioned to the reciprocal of this variable?">Reciprocal</label></div>
        <div class="col-8">
          <div class="btn-group btn-group-toggle btn-group-sm" data-toggle="buttons">
            <label class="btn btn-secondary active">
              <input type="radio" name="link-reciprocal-options" id="link-width-reciprocal" autocomplete="off" checked> Reciprocal
            </label>
            <label class="btn btn-secondary">
              <input type="radio" name="link-reciprocal-options" id="link-width-nonreciprocal" autocomplete="off"> Non-reciprocal
            </label>
          </div>
        </div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label for="link-width" data-toggle="tooltip" title="How thick should the links be?">Width</label></div>
        <div class="col-8"><input type="range" id="link-width" min="0.3" max="30" step=".3" value="3" /></div>
      </div>
      <div class="form-group row hideForHIVTrace">
        <div class="col-4"><label data-toggle="tooltip" title="Are these links directed?">Directionality</label></div>
        <div class="col-8">
          <div class="btn-group btn-group-toggle btn-group-sm" data-toggle="buttons">
            <label class="btn btn-secondary active">
              <input type="radio" name="DirectionOptions" id="link-undirected" autocomplete="off" checked> Undirected
            </label>
            <label class="btn btn-secondary">
              <input type="radio" name="DirectionOptions" id="link-directed" autocomplete="off"> Directed
            </label>
          </div>
        </div>
      </div>
    </div>
    <div class="tab-pane fade" id="network_settings" role="tabpanel" aria-labelledby="network-tab">
      <div class="form-group row">
        <div class="col-4"><label data-toggle="tooltip" title="How quickly should moving nodes lose their momentum?">Friction</label></div>
        <div class="col-8"><input type="range" id="network-friction" min="0" max="1" value="0.4" step="0.025" /></div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label data-toggle="tooltip" title="How long should links be?">Length</label></div>
        <div class="col-8"><input type="range" id="link-length" min = "0" max="200" value="50" /></div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label data-toggle="tooltip" title="How attractive is the mass of the graph?">Gravity</label></div>
        <div class="col-8"><input type="range" id="network-gravity" min="0.025" max="1" value="0.05" step="0.025" /></div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label data-toggle="tooltip" title="How strongly are the nodes repulsed by each other?">Charge</label></div>
        <div class="col-8"><input type="range" id="node-charge" min="0" max="400" value="200" /></div>
      </div>
      <div class="form-group row">
        <div class="col-4"><label data-toggle="tooltip" title="What color should the background be?">Background</label></div>
        <div class="col-8"><input type="color" id="network-color" class="custom-select custom-select-sm" value="#ffffff" /></div>
      </div>
    </div>
  </div>
</div>

<div id="context-menu" class="dropdown-menu">
  <a href="#" id="viewAttributes" class="dropdown-item">View Attributes</a>
  <a href="#" id="copyID" class="dropdown-item">Copy ID</a>
  <a href="#" id="copySeq" class="dropdown-item showForSequence">Copy Sequence</a>
  <a href="#" id="pinNode" class="dropdown-item">Pin Node</a>
  <div class="dropdown-divider" />
  <a href="#" id="isolateCluster" class="dropdown-item">Isolate Cluster</a>
  <a href="#" id="hideCluster" class="dropdown-item">Hide Cluster</a>
</div>

<div id="attributeModal" class="modal fade" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Node Attributes</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body" style="overflow: auto">
        <table class="table table-striped">
          <tbody></tbody>
        </table>
      </div>
      <div class="modal-footer">
        <button type="submit" class="btn btn-primary" data-dismiss="modal" title="">OK</button>
      </div>
    </div>
  </div>
</div>

<div id="export_svg_modal" class="modal fade" tabindex="-1" role="dialog" data-backdrop="false">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Export Network Image</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <div class="form-group row">
          <div class="col-9">
            <input type="text" id="export-svg-file-name" class="form-control form-control-sm" placeholder="Filename" />
          </div>
          <div class="col-3">
            <select id="export-img-file-type" class="form-control form-control-sm">
              <option selected>png</option>
              <option>svg</option>
            </select>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-error" data-dismiss="modal">Cancel</button>
        <button type="button" id="svg_export" class="btn btn-primary" data-dismiss="modal">Export</button>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div><!-- /.modal -->

<script>
(function(){

  session.network = {
    allPinned: false
  };

  let vnodes = [];

  function updateVNodes(){
    let newNodes = app.getVisibleNodes(true);
    newNodes.forEach((d, i) => {
      let match = vnodes.find(d2 => d2.id == d.id);
      if(match){
        d.x = match.x;
        d.y = match.y;
        d.fx = match.fx;
        d.fy = match.fy;
        d.vx = match.vx;
        d.vy = match.vy;
      }
    });
    vnodes = newNodes;
  }

  let brush = d3.brush()
    .on('start', brushstarted)
    .on('brush', brushed)
    .on('end', brushended);

  function brushstarted(){
    vnodes.forEach(d => {
      d.previouslySelected = d.selected;
    });
  }

  let transform = {};

  function brushed(){
    if(d3.event.sourceEvent.type === 'end') return;
    let selection = [
      transform.invert(d3.event.selection[0]),
      transform.invert(d3.event.selection[1])
    ];
    if(selection.includes(null)) return;
    if(d3.event.sourceEvent.ctrlKey){
      vnodes.forEach(function(d){
        d.selected = d.previouslySelected ^ (
          selection[0][0] <= d.x && d.x <= selection[1][0] &&
          selection[0][1] <= d.y && d.y <= selection[1][1]);
      });
    } else {
      vnodes.forEach(function(d){
        d.selected =
          selection[0][0] <= d.x && d.x <= selection[1][0] &&
          selection[0][1] <= d.y && d.y <= selection[1][1];
      });
    }
  }

  function brushended() {
    if (d3.event.selection == null) return;
    d3.select(this).call(d3.event.target.move, null);
    vnodes.forEach(d => delete d.previouslySelected);
    session.data.nodes.forEach(node => {
      let instance = vnodes.find(d => d.id === node.id);
      if(instance) node.selected = instance.selected;
    });
    $(window).trigger('node_selected');
  }

  let zoom = d3.zoom().on('zoom', function(){
    svg.attr('transform', d3.event.transform);
    transform = d3.event.transform;
  });

  let width  = $('#network').parent().width(),
      height = $('#network').parent().parent().parent().height();

  d3.select('svg#network')
    .html(null) //Let's make sure the canvas is blank.
    .attr('height', height)
    .attr('width', width)
    .on('click', hideContextMenu)
    .call(zoom);

  d3.select('svg#network')
      .append('g')
      .attr('class', 'brush')
      .call(brush)
      .attr('pointer-events', 'none')
    .select('rect.overlay')
      .attr('pointer-events', 'none');

  let svg = d3.select('svg#network').append('g');

  let fit = function(thing, bounds){
    if(!bounds) bounds = svg.node().getBBox();
    if (bounds.width === 0 || bounds.height === 0) return; // nothing to fit
    let parent = svg.node().parentElement.parentElement,
        midX = bounds.x + bounds.width / 2,
        midY = bounds.y + bounds.height / 2;
    let scale = 0.95 / Math.max(bounds.width / parent.clientWidth, bounds.height / parent.clientHeight);
    d3.select('svg#network')
      .transition()
      .duration(750)
      .call(zoom.transform, d3.zoomIdentity
        .translate(parent.clientWidth / 2 - scale * midX, parent.clientHeight / 2 - scale * midY)
        .scale(scale));
  };

  let force = d3.forceSimulation()
    .force('link', d3.forceLink()
      .id(d => d.id)
      .distance(session.style.widgets['link-length'])
      .strength(0.125)
    )
    .force('charge', d3.forceManyBody()
      .strength(-session.style.widgets['node-charge'])
    )
    .force('gravity', d3.forceAttract()
      .target([width/2, height/2])
      .strength(session.style.widgets['network-gravity'])
    )
    .force('center', d3.forceCenter(width / 2, height / 2));

  svg.append('svg:defs').append('marker')
    .attr('id', 'end-arrow')
    .attr('viewBox', '0 0 10 10')
    .attr('refX', 20)
    .attr('refY', 5)
    .attr('markerWidth', 4)
    .attr('markerHeight', 4)
    .attr('orient', 'auto')
    .append('svg:path')
      .attr('d', 'M0,0 L0,10 L10,5 z');

  svg.append('g').attr('id', 'links');
  svg.append('g').attr('id', 'nodes');

  let render = function(){
    //OK, this is a little bit of expert-level D3 voodoo that deserves some explanation.
    let node = svg.select('g#nodes').selectAll('g.node').data(vnodes);
    node.exit().remove(); //Removing nodes with no representation in the dataset.
    node = node.enter().append('g') //Adding nodes that weren't represented in the dataset before.
      .attr('class', 'node')
      .attr('tabindex', '0')
      .call(d3.drag() //A bunch of mouse handlers.
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended))
      .on('mouseenter focusin', showNodeToolTip)
      .on('mouseout focusout', hideTooltip)
      .on('contextmenu', showContextMenu)
      .on('click', clickHandler)
      .on('keydown', n => {
        if(d3.event.code === 'Space') clickHandler(n);
        if(d3.event.shiftKey && d3.event.key === 'F10') showContextMenu(n);
      });

    // What's this?
    node.append('path')  // Adding a path?
      .attr('stroke', '#ffffff')
      .attr('stroke-width', '2px');
    node.append('text'); // And a text? Wouldn't those already be attached to the nodes?
    // Well, they would for nodes that already existed. The wouldn't for new nodes.
    // And until we merge the old and new nodes, `node` refers only to the *added* nodes.
    // Speaking of merging...
    node = node.merge(node);
    // E voila! node now refers to all the g.node elements in the network,
    // and they all have path and text elements, so we can confidently append our label text
    node.select('text')
      .attr('dy', 5)
      .attr('dx', 8);

    // And style them according to the DOM State instructions.
    redrawNodes();
    updateNodeColors();

    let vlinks = getVLinks();

    // Links are considerably simpler.
    let link = svg.select('g#links').selectAll('line').data(vlinks);
    link.exit().remove();
    link.enter().append('line')
      .attr('stroke-width', session.style.widgets['link-width'])
      .attr('opacity', 1 - session.style.widgets['link-opacity'])
      .on('mouseenter', showLinkToolTip)
      .on('mouseout', hideTooltip);

    let nodes = svg.select('g#nodes').selectAll('g.node').data(vnodes);
    let links = svg.select('g#links').selectAll('line').data(vlinks);
    force.nodes(vnodes).on('tick', function(){
      nodes
        .attr('transform', d => d.fixed ? `translate(${d.fx}, ${d.fy})` : `translate(${d.x}, ${d.y})`);
      links
        .attr('x1', l => l.source.x)
        .attr('y1', l => l.source.y)
        .attr('x2', l => l.target.x)
        .attr('y2', l => l.target.y);
    });

    force.force('link').links(vlinks);

    updateLinkColor();
    scaleLinkWidth();
    nodes.select('path').classed('selected', d => d.selected);
    force.alpha(0.3).alphaTarget(0).restart();
  };

  function getVLinks(){
    let vlinks = app.getVisibleLinks(true);
    let output = [];
    let n = vlinks.length;
    for(let i = 0; i < n; i++){
      if(vlinks[i].origin){
        if(typeof vlinks[i].origin === 'object'){
          vlinks[i].origin.forEach((o, j, l) => {
            output.push(Object.assign({}, vlinks[i], {
              origin: o,
              oNum: j,
              origins: l.length,
              source: vnodes.find(d => d.id === vlinks[i].source),
              target: vnodes.find(d => d.id === vlinks[i].target)
            }));
          });
        } else {
          output.push(Object.assign({}, vlinks[i], {
            oNum: 0,
            origins: 1,
            source: vnodes.find(d => d.id === vlinks[i].source),
            target: vnodes.find(d => d.id === vlinks[i].target)
          }));
        }
      } else {
        output.push(Object.assign({}, vlinks[i], {
          origin: 'Unknown',
          oNum: 0,
          origins: 1,
          source: vnodes.find(d => d.id === vlinks[i].source),
          target: vnodes.find(d => d.id === vlinks[i].target)
        }));
      }
    }
    return output;
  }

  function dragstarted(d){
    if (!d3.event.active) force.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(d){
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }

  function dragended(d){
    if (!d3.event.active) force.alphaTarget(0);
    if(!d.fixed){
      d.fx = null;
      d.fy = null;
    }
  }

  function clickHandler(n){
    if(!d3.event.ctrlKey){
      session.data.nodes
        .filter(node => node.id !== n.id)
        .forEach(node => node.selected = false);
    }
    session.data.nodes.find(node => node.id === n.id).selected = !n.selected;
    $(window).trigger('node_selected');
  }

  new Clipboard('#copyID, #copySeq');

  function showContextMenu(d){
    d3.event.preventDefault();
    hideTooltip();
    $('#copyID').attr('data-clipboard-text', d.id);
    $('#copySeq').attr('data-clipboard-text', d.seq);
    d3.select('#viewAttributes').on('click', e => {
      showAttributeModal(d);
    }).node().focus();
    if(d.fixed){
      $('#pinNode').text('Unpin Node').on('click', e => {
        d.fx = null;
        d.fy = null;
        d.fixed = false;
        force.alpha(0.3).alphaTarget(0).restart();
        hideContextMenu();
      });
    } else {
      $('#pinNode').text('Pin Node').on('click', e => {
        d.fx = d.x;
        d.fy = d.y;
        d.fixed = true;
        hideContextMenu();
      });
    }
    $('#hideCluster').on('click', e => {
      session.data.clusters.find(c => c.id == d.cluster).visible = false;
      app.setLinkVisibility();
      app.setNodeVisibility();
      render();
      hideContextMenu();
    });
    if(session.data.clusters.length <= 1){
      $('#isolateCluster').hide();
    } else {
      if(session.data.clusters.filter(c => c.visible).length === 1){
        $('#isolateCluster').show().text('De-isolate Cluster').on('click', e => {
          session.data.clusters.forEach(c => c.visible = true);
          app.setLinkVisibility();
          app.setNodeVisibility();
          render();
          hideContextMenu();
        });
      } else {
        $('#isolateCluster').show().text('Isolate Cluster').on('click', e => {
          session.data.clusters.forEach(c => c.visible = c.id === d.cluster);
          app.setLinkVisibility();
          app.setNodeVisibility();
          render();
          hideContextMenu();
        });
      }
    }
    $('#context-menu').css({
      'z-index': 1000,
      'display': 'block',
      'left': (d3.event.pageX) + 'px',
      'top': (d3.event.pageY-56) + 'px',
    }).animate({'opacity': 1}, 80);
  }

  function hideContextMenu(){
    $('#context-menu').animate({'opacity': 0}, 80, function(){
      $(this).css('z-index', -1);
    });
  }

  function showAttributeModal(node){
    hideContextMenu();
    let target = $('#attributeModal tbody').empty();
    let d = session.data.nodes.find(nd => nd.id === node.id);
    for(let attribute in d){
      target.append(`<tr><td><strong>${app.titleize(attribute)}</strong></td><td>${d[attribute]}</td></tr>`);
    }
    $('#attributeModal').modal('show');
  }

  function showNodeToolTip(d){
    if(session.style.widgets['node-highlight']) highlightNeighbors(d);
    if($('#node-tooltip-variable').val() === 'None') return;
    d3.select('#tooltip')
      .html(d[$('#node-tooltip-variable').val()])
      .style('left', (d3.event.pageX + 8) + 'px')
      .style('top', (d3.event.pageY - 28) + 'px')
      .style('z-index', 1000)
      .transition().duration(100)
      .style('opacity', 1);
  }

  function highlightNeighbors(node){
    let links = getVLinks();
    let lindices = [], neighbors = [node.id];
    let n = links.length;
    for(let i = 0; i < n; i++){
      let l = links[i];
      if(l.source.id !== node.id && l.target.id !== node.id){
        lindices.push(l.index);
      } else {
        if(l.source.id === node.id){
          neighbors.push(l.target.id);
        } else {
          neighbors.push(l.source.id);
        }
      }
    }
    svg
      .select('g#nodes')
      .selectAll('g.node')
      .selectAll('path')
      .attr('opacity', d => neighbors.includes(d.id) ? 1 : .1);
    svg
      .select('g#links')
      .selectAll('line')
      .data(links)
      .attr('opacity', l => lindices.includes(l.index) ? .1 : 1);
  }

  $('#link-tooltip-variable').on('change', function(e){
    session.style.widgets['link-tooltip-variable'] = e.target.value;
  });

  function showLinkToolTip(d){
    let v = session.style.widgets['link-tooltip-variable'];
    if(v === 'None') return;
    d3.select('#tooltip')
      .html((v === 'source' || v === 'target') ? d[v].id : d[v])
      .style('left', (d3.event.pageX + 8) + 'px')
      .style('top', (d3.event.pageY - 28) + 'px')
      .style('z-index', 1000)
      .transition().duration(100)
      .style('opacity', 1);
  }

  $('#highlight-neighbors').parent().on('click', function(){
    session.style.widgets['node-highlight'] = true;
  });

  $('#dont-highlight-neighbors').parent().on('click', function(){
    session.style.widgets['node-highlight'] = false;
  });

  function hideTooltip(){
    if(session.style.widgets['node-highlight']){
      svg
        .select('g#nodes')
        .selectAll('g.node')
        .selectAll('path')
        .attr('opacity', 1);
      let linkOpacity = 1 - session.style.widgets['link-opacity'];
      svg
        .select('g#links')
        .selectAll('line')
        .attr('opacity', linkOpacity);
    }
    let tooltip = d3.select('#tooltip');
    tooltip
      .transition().duration(100)
      .style('opacity', 0)
      .on('end', () => tooltip.style('z-index', -1));
  }

  function redrawNodes(){
    //Things to track in the function:
    //* Shapes:
    let type = d3[session.style.widgets['node-symbol']];
    let symbolVariable = session.style.widgets['node-symbol-variable'];
    //* Sizes:
    let defaultSize = session.style.widgets['node-radius'];
    let size = defaultSize, med = defaultSize, oldrng, min, max;
    let sizeVariable = session.style.widgets['node-radius-variable'];
    if(sizeVariable !== 'None'){
      let n = vnodes.length;
      min = Number.MAX_VALUE;
      max = Number.MIN_VALUE;
      for(let i = 0; i < n; i++){
        if(typeof vnodes[i][sizeVariable] === 'undefined') continue;
        if(vnodes[i][sizeVariable] < min) min = vnodes[i][sizeVariable];
        if(vnodes[i][sizeVariable] > max) max = vnodes[i][sizeVariable];
      }
      oldrng = max - min;
      med = oldrng / 2;
    }
    let nodes = svg.select('g#nodes').selectAll('g.node').data(vnodes);
    nodes.select('path').each(function(d){
      if(symbolVariable !== 'None') type = d3[session.style.nodeSymbolMap(d[symbolVariable])];
      if(sizeVariable !== 'None'){
        size = med;
        if(typeof d[sizeVariable] !== 'undefined'){
          size = d[sizeVariable];
        }
        size = (size - min) / oldrng;
        size = size * size * defaultSize + 100;
      }
      d3.select(this).attr('d', d3.symbol().size(size).type(type));
    });
    //* and Labels:
    let labelVar = session.style.widgets['node-label-variable'];
    if(labelVar === 'None'){
      nodes.select('text').text('');
    } else {
      nodes.select('text').text(n => n[labelVar]);
    }
  }

  $('#toggle_2d_network_settings').on('click', function(){
    let pane = $('#network_settings_pane');
    if($(this).hasClass('active')){
      pane.animate({left: '-400px'}, function(){ pane.hide(); });
    } else {
      pane.show(0, function(){ pane.animate({left: '0px'}); });
    }
  });

  $('#node-label-variable').on('change', e => {
    session.style.widgets['node-label-variable'] = e.target.value;
    redrawNodes();
  });

  $('#node-tooltip-variable').on('change', e => {
    session.style.widgets['node-tooltip-variable'] = e.target.value;
  });

  $('#node-symbol').on('input', e => {
    session.style.widgets['node-symbol'] = e.target.value;
    redrawNodes();
  });
  $('#node-symbol-variable').on('change', e => {
    session.style.widgets['node-symbol-variable'] = e.target.value;
    $('#nodeShapes').fadeOut(function(){$(this).remove()});
    let table = $('<tbody id="nodeShapes"></tbody>').appendTo('#group-key');
    if(e.target.value === 'None'){
      redrawNodes();
      $('#node_shape_value_row').slideDown();
      return table.fadeOut(e => table.remove());
    }
    $('#node_shape_value_row').slideUp();
    table.append('<tr><th contenteditable>Node '+app.titleize(e.target.value)+'</th><th>Shape</th><tr>');
    let values = _.uniq(vnodes.map(d => d[e.target.value])).sort();
    session.style.nodeSymbolMap = d3.scaleOrdinal(session.style.nodeSymbols).domain(values);
    let options = $('#node-symbol').html();
    values.forEach((v, i) => {
      let selector = $('<select></select>').append(options).val(session.style.nodeSymbolMap(v)).on('change', function(e){
        session.style.nodeSymbols.splice(i, 1, e.target.value);
        session.style.nodeSymbolMap = d3.scaleOrdinal(session.style.nodeSymbols).domain(values);
        redrawNodes();
      });
      let cell = $('<td></td>').append(selector);
      let row = $('<tr><td contenteditable>' + app.titleize(''+v) + '</td></tr>').append(cell);
      table.append(row);
    });
    redrawNodes();
    table.fadeIn();
  });

  $('#node-radius').on('input', function(e){
    session.style.widgets['node-radius'] = parseFloat(e.target.value);
    redrawNodes();
  });
  $('#node-radius-variable').on('change', function(e){
    session.style.widgets['node-radius-variable'] = e.target.value;
    redrawNodes();
  });

  $(window).on('node-color-change', updateNodeColors);

  function updateNodeColors(){
    let variable = session.style.widgets['node-color-variable'];
    let nodes = svg.select('g#nodes').selectAll('g.node').select('path');
    if(variable === 'None'){
      let col = session.style.widgets['node-color'];
      nodes.attr('fill', col);
    } else {
      nodes.data(vnodes).attr('fill', d => session.style.nodeColorMap(d[variable]));
    }
  }

  $('#node-charge').on('input', e => {
    let v = parseFloat(e.target.value);
    force.force('charge').strength(-v);
    force.alpha(0.3).alphaTarget(0).restart();
    session.style.widgets['node-charge'] = v;
  });

  $('#link-directed').parent().on('click', e => {
    svg.select('g#links').selectAll('line').attr('marker-end', 'url(#end-arrow)');
    session.style.widgets['link-directed'] = true;
  });

  $('#link-undirected').parent().on('click', e => {
    svg.select('g#links').selectAll('line').attr('marker-end', null);
    session.style.widgets['link-directed'] = false;
  });

  $('#link-length').on('input', e => {
    let v = parseFloat(e.target.value);
    force.force('link').distance(e.target.value);
    force.alpha(0.3).alphaTarget(0).restart();
    session.style.widgets['link-length'] = v;
  });

  function updateLinkColor(e){
    let variable = session.style.widgets['link-color-variable'];
    let links = svg.select('g#links').selectAll('line');
    if(variable === 'None'){
      let color = session.style.widgets['link-color'];
      links.attr('stroke', color);
    } else {
      links
        .data(getVLinks())
        .attr('stroke', l => session.style.linkColorMap(l[variable]))
        .attr('stroke-dasharray', l => {
          //This quirky little algorithm creates the dasharray code necessary to make dash-y links.
          let length = 15;
          let out = new Array(l.origins * 2);
          let ofs = new Array(l.origins).fill(1);
          let ons = new Array(l.origins).fill(0);
          ons[l.oNum] = 1;
          ofs[l.oNum] = 0;
          for(let i = 0; i < l.origins; i++){
            out[2*i] = ons[i] * length;
            out[2*i + 1] = ofs[i] * length;
          }
          return out.join(', ');
        });
    }
  }

  $(window).on('link-color-change', updateLinkColor);

  $('#link-opacity').on('input', e => {
    session.style.widgets['link-opacity'] = parseFloat(e.target.value);
    let opacity = 1 - parseFloat(e.target.value);
    svg.select('g#links').selectAll('line').attr('opacity', opacity);
  });

  function scaleLinkWidth(){
    let scalar = session.style.widgets['link-width'];
    let variable = session.style.widgets['link-width-variable'];
    let vlinks = getVLinks();
    let links = svg.select('g#links').selectAll('line').data(vlinks);
    if(variable === 'None') return links.attr('stroke-width', scalar);
    let values = vlinks.map(l => l[variable]).filter(_.isNumber);
    let max = Math.max(...values);
    let min = Math.min(...values);
    let mid = (max-min) / 2 + min;
    let scale = d3.scaleLinear()
      .domain(session.style.widgets['link-width-reciprocal'] ? [max, min] : [min, max])
      .range([1, scalar]);
    links.attr('stroke-width', d => {
      let v = d[variable];
      if(!_.isNumber(v)) v = mid;
      return scale(v);
    });
  }

  $('#link-width').on('input', e => {
    session.style.widgets['link-width'] = parseFloat(e.target.value);
    scaleLinkWidth();
  });

  $('#link-width-variable').on('change', e => {
    if(e.target.value === 'None'){
      $('#link-reciprocalthickness-row').slideUp();
    } else {
      $('#link-reciprocalthickness-row').css('display', 'flex');
    }
    session.style.widgets['link-width-variable'] = e.target.value;
    scaleLinkWidth();
  });

  $('#link-width-reciprocal').parent().on('click', function(){
    session.style.widgets['link-width-reciprocal'] = true;
    scaleLinkWidth();
  });

  $('#link-width-nonreciprocal').parent().on('click', function(){
    session.style.widgets['link-width-reciprocal'] = false;
    scaleLinkWidth();
  });

  $('#network-friction').on('input', e => {
    let v = parseFloat(e.target.value);
    force.velocityDecay(v);
    force.alpha(0.3).alphaTarget(0).restart();
    session.style.widgets['network-friction'] = v;
  });

  $('#network-gravity').on('input', e => {
    let v = parseFloat(e.target.value);
    force.force('gravity').strength(v);
    force.alpha(0.3).alphaTarget(0).restart();
    session.style.widgets['network-gravity'] = v;
  });

  $('#network-color').on('input', e => $('#network').css('background-color', e.target.value));

  $('#svg_export').on('click', function(){
    let network = document.getElementById('network');
    let content = app.unparseSVG(network);
    let filetype = $('#export-img-file-type').val();
    if(filetype === 'svg'){
      let blob = new Blob([content], {type: 'image/svg+xml;charset=utf-8'});
      saveAs(blob, $('#export-svg-file-name').val() + '.' + filetype);
    } else {
      app.blobifySVG(content, network.width.baseVal.value, network.height.baseVal.value, 'png', function(blob, size){
        saveAs(blob, $('#export-svg-file-name').val() + '.' + filetype);
      });
    }
  });

  $('#fitbutton').on('click', fit);

  $('#pinbutton').on('click', function(){
    let nodes = svg
      .select('g#nodes')
      .selectAll('g.node')
      .data(vnodes)
      .select('path');
    if(session.network.allPinned){
      nodes.each(function(d){
        delete d.fx;
        delete d.fy;
        d.fixed = false;
      });
      force.alpha(0.3).alphaTarget(0).restart();
    } else {
      nodes.each(function(d){
        d.fx = d.x;
        d.fy = d.y;
        d.fixed = true;
      });
    }
    session.network.allPinned = !session.network.allPinned;
  });

  d3.select(window).on('keydown keyup', function(){
    d3.select('g.brush')
        .attr('pointer-events', d3.event.ctrlKey ? 'all' : 'none')
      .select('rect.overlay')
        .attr('pointer-events', d3.event.ctrlKey ? 'all' : 'none');
  });

  $(window).on('link-threshold-change node_visibility node_selected', function(){
    updateVNodes(); //Update network's copy of data model
    render();       //Draw it
  });

  layout.on('stateChanged', function(){ setTimeout(fit, 1200); });

  if(session.files.length > 1) $('#link-color-variable').val('origin').change();
  updateVNodes();
  render();
})();
</script>
