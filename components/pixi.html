<div id="pixi">
  <canvas id='pixiCanvas'></canvas>
</div>



<script type="text/javascript">
  ( async () => {
    // config
    const SCREEN_WIDTH = $('#pixi').parent().width();
    const SCREEN_HEIGHT = $('#pixi').parent().parent().parent().height();
    let halfWidth = $('#pixi').parent().width() / 2;
    let halfHeight = $('#pixi').parent().parent().parent().height() / 2;
    //const WORLD_WIDTH = SCREEN_WIDTH * 2;
    //const WORLD_HEIGHT = SCREEN_HEIGHT * 2;
    //const RESOLUTION = window.devicePixelRatio * 2;
    const WORLD_WIDTH = SCREEN_WIDTH;
    const WORLD_HEIGHT = SCREEN_HEIGHT;
    const RESOLUTION = window.devicePixelRatio;
    const FORCE_LAYOUT_NODE_REPULSION_STRENGTH = 250;
    const FORCE_LAYOUT_ITERATIONS = 300;
    const NODE_RADIUS = 15;
    const NODE_HIT_RADIUS = NODE_RADIUS + 5;
    const ICON_FONT_FAMILY = 'Material Icons';
    const ICON_FONT_SIZE = NODE_RADIUS / Math.SQRT2 * 2;
    const ICON_TEXT = 'person';
    const LABEL_FONT_FAMILY = 'Helvetica';
    const LABEL_FONT_SIZE = 12;
    const LABEL_TEXT = nodeData => nodeData.id;
    const LABEL_X_PADDING = 2;
    const LABEL_Y_PADDING = 1;

    let settings = session.style.widgets;

    let data = {
      nodes: [],
      links: []
    };


    const forceLayout = (...args) => {
    //   return new Promise(resolve => {
    //     const workerCode = `

    //       function forceLayout(data, options = {}) {
    //         const nodes = data.nodes;
    //         const links = data.links;

    //         const iterations = options.iterations;
    //         const nodeRepulsionStrength = options.nodeRepulsionStrength;

    //         d3.forceSimulation(nodes)
    //           .force("link", d3.forceLink(links).id(linkData => linkData.id))
    //           .force("charge", d3.forceManyBody().strength(-nodeRepulsionStrength))
    //           .force("center", d3.forceCenter())
    //           .stop()
    //           .tick(iterations);

    //         return { nodes, links };
    //       };

    //       self.onmessage = event => {
    //         const result = forceLayout.apply(undefined, event.data);
    //         postMessage(result);
    //       }
    //     `;

    //     const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
    //     const workerUrl = URL.createObjectURL(workerBlob)
    //     const worker = new Worker(workerUrl);

    //     worker.onmessage = event => {
    //       resolve(event.data);
    //       worker.terminate();
    //       URL.revokeObjectURL(workerUrl);
    //     };
    //     worker.postMessage(args);
    //   });
      
      return new Promise((resolve) => {
        const [data, { iterations, nodeRepulsionStrength }] = args

        // console.log('data nodes', data.nodes)
        let force = d3.forceSimulation(data.nodes)
          .force('link', d3.forceLink(data.links)
            .id(d => d._id)
            .distance(l => l.origin.length * settings['link-length'])
            .strength(0.125)
          )
          .force('charge', d3.forceManyBody()
            .strength(-settings['node-charge'])
          )
          .force('center', d3.forceCenter(halfWidth, halfHeight))
          .force('gravity', d3.forceAttract()
            .target([halfWidth, halfHeight])
            .strength(settings['network-gravity'])
          )
          
          // .stop()
          .tick(iterations);

          force.velocityDecay(settings['network-friction']);

        resolve(data)
      })
    }

    function getVLinks() {
      let vlinks = MT.getVisibleLinks(true);
      let output = [];
      let n = vlinks.length;
      let nodes = session.network.nodes;
      for (let i = 0; i < n; i++) {
        if (vlinks[i].origin) {
          if (typeof vlinks[i].origin == 'object') {
            vlinks[i].origin.forEach((o, j, l) => {
              output.push(Object.assign({}, vlinks[i], {
                origin: o,
                oNum: j,
                origins: l.length,
                source: nodes.find(d => d._id == vlinks[i].source || d.id == vlinks[i].source),
                target: nodes.find(d => d._id == vlinks[i].target || d.id == vlinks[i].target)
              }));
            });
          } else {
            output.push(Object.assign({}, vlinks[i], {
              oNum: 0,
              origins: 1,
              source: nodes.find(d => d._id == vlinks[i].source || d.id == vlinks[i].source),
              target: nodes.find(d => d._id == vlinks[i].target || d.id == vlinks[i].target)
            }));
          }
        } else {
          output.push(Object.assign({}, vlinks[i], {
            origin: 'Unknown',
            oNum: 0,
            origins: 1,
            source: nodes.find(d => d._id == vlinks[i].source || d.id == vlinks[i].source),
            target: nodes.find(d => d._id == vlinks[i].target || d.id == vlinks[i].target)
          }));
        }
      }
      return output;
    }

    
    let newNodes = MT.getVisibleNodes(true);
    let oldNodes = session.network.nodes;

    newNodes.forEach((d, i) => {
      let match = oldNodes.find(d2 => d2._id == d._id);
      if (match) {
        ['x', 'y', 'fx', 'fy', 'vx', 'vy', 'fixed'].forEach(v => {
          if (typeof match[v] != "undefined") d[v] = match[v];
        });
      }
    });

    session.network.nodes = newNodes;

    data.nodes = newNodes;
    data.links = getVLinks();

    var pixiCanvas = d3.select('#pixiCanvas');

    const app = new PIXI.Application({
      width: SCREEN_WIDTH,
      height: SCREEN_HEIGHT,
      resolution: RESOLUTION,
      transparent: true,
      antialias: true,
      view: pixiCanvas.node()
      // autoStart: false // disable automatic rendering by ticker, render manually instead, only when needed
    });


    const viewport = new Viewport.Viewport({
        screenWidth: SCREEN_WIDTH,
        screenHeight: SCREEN_HEIGHT,
        worldWidth: SCREEN_WIDTH,
        worldHeight: SCREEN_HEIGHT
    });


    viewport.wheel().drag().decelerate();
    app.stage.addChild(viewport);

    // var renderer = new PIXI.WebGLRenderer(1000, 1000, 
    //   { antialias: true, backgroundColor : 0xffffff });
    // document.getElementById('pixi').appendChild(renderer.view);

    document.getElementById('pixi').appendChild(app.view);
      
    // document.body.appendChild(app.view);


		// create the root of the scene graph
		var stage = app.stage;

    let simulation = d3.forceSimulation()
      .force('link', d3.forceLink()
        .id(d => d._id)
        .distance(l => l.origin.length * settings['link-length'])
        .strength(0.125)
      )
      // .force('link', d3.forceLink().id((d) => d._id))
      .force('charge', d3.forceManyBody()
        .strength(-settings['node-charge'])
      )
      // .force('charge', d3.forceManyBody())
      .force('gravity', d3.forceAttract()
        .target([halfWidth, halfHeight])
        .strength(settings['network-gravity'])
      )
      .force('center', d3.forceCenter(halfWidth, halfHeight));
     
      

    let render = () => {
      console.log('render')

      const start = Date.now();
      let newNodes = MT.getVisibleNodes(true);
      let oldNodes = session.network.nodes;

      newNodes.forEach((d, i) => {
        let match = oldNodes.find(d2 => d2._id == d._id);
        if (match) {
          ['x', 'y', 'fx', 'fy', 'vx', 'vy', 'fixed'].forEach(v => {
            if (typeof match[v] != "undefined") d[v] = match[v];
          });
        }
      });

      // parseInt(str.replace(/^#/, ''), 16)

      session.network.nodes = newNodes;

      let links = new PIXI.Graphics();
      viewport.addChild(links);

      let variable = settings['node-color-variable'];

      let defaultSize = settings['node-radius'];
      let size = defaultSize, med = defaultSize, oldrng, min, max;
      console.log('size node', size);

      // updateNodeColors();
      newNodes.forEach((node) => {

        node.gfx = new PIXI.Graphics();
        node.gfx.lineStyle(1.5, 0xFFFFFF);
        
        if (variable == 'None') {
          let fill = settings['node-color'];
          // nodes.attr('fill', col).attr('opacity', 1);
          node.gfx.beginFill(parseInt(fill.replace(/^#/, ''), 16), 1);
        } else {
          let fill = temp.style.nodeColorMap(node[variable]);
          console.log('fill', fill);
          let alpha = temp.style.nodeAlphaMap(node[variable]);
          node.gfx.beginFill(parseInt(fill.replace(/^#/, ''), 16), parseInt(alpha));
        }
        // node.gfx.endFill();
        // node.gfx.beginFill(parseInt(settings['node-color'].replace(/^#/, ''), 16));
        node.gfx.drawCircle(0, 0, 5);

        node.gfx.interactive = true;

        node.gfx.on("pointerdown", onDragStart)
        node.gfx.on("pointerup", onDragEnd)
        node.gfx.on("pointerupoutside", onDragEnd)
        node.gfx.on("pointermove", onDragMove);

     
        
        viewport.addChild(node.gfx);
      });

      // d3.select(app.view)
      // pixiCanvas.call(d3.drag()
      //     .container(pixiCanvas.node())
      //     .subject(() => simulation.find(d3.event.x, d3.event.y, 4))
      //     .on('start', dragstarted)
      //     .on('drag', dragged)
      //     .on('end', dragended));
      
      let vlinks = getVLinks();

      // console.log('vlinks', vlinks);

      // console.log('pixi',newNodes);

      simulation
        .nodes(newNodes)
        .on('tick', ticked);

      simulation.force('link')
        .links(vlinks);

      function ticked() {
        newNodes.forEach((node) => {
            let { x, y, gfx } = node;
            gfx.position = new PIXI.Point(x, y);
        });

        links.clear();
        links.alpha = 0.6;

        vlinks.forEach((link) => {
            let { source, target } = link;
            links.lineStyle(2, parseInt('#D3D3D3'.replace(/^#/, ''), 16), 1);
            links.moveTo(source.x, source.y);
            links.lineTo(target.x, target.y);
        });

        links.endFill();

        app.render();

      }


    }




    function onDragStart(event) {
      viewport.plugins.pause('drag')
      simulation.alphaTarget(0.3).restart();

      

      this.isDown = true;
      this.event = event.data;
      this.alpha = 0.5;
      this.dragging = true;
      globalDragging = true;

    }

    function onDragEnd(event) {
        if (!event.active) simulation.alphaTarget(0);
        this.alpha = 1;
        this.dragging = false;
        this.isOver = false;
        this.event = null;
        globalDragging = false;
        viewport.plugins.resume('drag')
    }

    function onDragMove(event) {
     
        if (this.dragging) {
           
            const newPosition = this.event.getLocalPosition(this.parent);

            console.log('new position', newPosition)

           
            this.fx = newPosition.x;
            this.fy = newPosition.y;

            
        }
    }

    function dragstarted() {
      viewport.plugins.pause('drag')
      if (!d3.event.active) simulation.alphaTarget(0.3).restart();
      d3.event.subject.fx = d3.event.subject.x;
      d3.event.subject.fy = d3.event.subject.y;
    }

    function dragged() {
      d3.event.subject.fx = d3.event.x;
      d3.event.subject.fy = d3.event.y;
    }

    function dragended() {
      if (!d3.event.active) simulation.alphaTarget(0);
      d3.event.subject.fx = null;
      d3.event.subject.fy = null;
      viewport.plugins.resume('drag')
    }
    

    function updateNodeColors() {
      let variable = settings['node-color-variable'];
      session.network.nodes.forEach((node) => {
        node.gfx.clear();
        if (variable == 'None') {
            let fill = settings['node-color'];
            // nodes.attr('fill', col).attr('opacity', 1);
            node.gfx.beginFill(parseInt(fill.replace(/^#/, ''), 16), 1);
        } else {
          
          let fill = temp.style.nodeColorMap(node[variable]);
          let alpha = temp.style.nodeAlphaMap(node[variable]);
          node.gfx.beginFill(parseInt(fill.replace(/^#/, ''), 16), parseInt(alpha));
        
        }
        node.gfx.drawCircle(0, 0, 5);
        renderer.render(stage);

      });
    }


    
    // function animate() {
    //   requestAnimationFrame(animate);
    //   renderer.render(stage);
    // }

   
    function getVLinks() {
      let vlinks = MT.getVisibleLinks(true);
      let output = [];
      let n = vlinks.length;
      let nodes = session.network.nodes;
      for (let i = 0; i < n; i++) {
        if (vlinks[i].origin) {
          if (typeof vlinks[i].origin == 'object') {
            vlinks[i].origin.forEach((o, j, l) => {
              output.push(Object.assign({}, vlinks[i], {
                origin: o,
                oNum: j,
                origins: l.length,
                source: nodes.find(d => d._id == vlinks[i].source || d.id == vlinks[i].source),
                target: nodes.find(d => d._id == vlinks[i].target || d.id == vlinks[i].target)
              }));
            });
          } else {
            output.push(Object.assign({}, vlinks[i], {
              oNum: 0,
              origins: 1,
              source: nodes.find(d => d._id == vlinks[i].source || d.id == vlinks[i].source),
              target: nodes.find(d => d._id == vlinks[i].target || d.id == vlinks[i].target)
            }));
          }
        } else {
          output.push(Object.assign({}, vlinks[i], {
            origin: 'Unknown',
            oNum: 0,
            origins: 1,
            source: nodes.find(d => d._id == vlinks[i].source || d.id == vlinks[i].source),
            target: nodes.find(d => d._id == vlinks[i].target || d.id == vlinks[i].target)
          }));
        }
      }
      return output;
    }

    render();



    // static force-directed layout, running in WebWorker thread
    // let { nodes, links } = await forceLayout(data, {
    //   iterations: FORCE_LAYOUT_ITERATIONS,
    //   nodeRepulsionStrength: FORCE_LAYOUT_NODE_REPULSION_STRENGTH
    // });

    // const app = new PIXI.Application({
    //   width: SCREEN_WIDTH,
    //   height: SCREEN_HEIGHT,
    //   resolution: RESOLUTION,
    //   transparent: true,
    //   antialias: true,
    //   autoStart: false // disable automatic rendering by ticker, render manually instead, only when needed
    // });
    // app.view.style.width = `${SCREEN_WIDTH}px`;

    // // manual rendering
    // // app.renderer.on('postrender', () => { console.log('render'); });
    // let renderRequestId = undefined;
    // const requestRender = () => {
    //   if (renderRequestId) {
    //     return;
    //   }
    //   renderRequestId = window.requestAnimationFrame(() => {
    //     app.render();
    //     renderRequestId = undefined;
    //   });
    // }
    
    // // create PIXI viewport
    // const viewport = new Viewport.Viewport({
    //   screenWidth: SCREEN_WIDTH,
    //   screenHeight: SCREEN_HEIGHT,
    //   worldWidth: WORLD_WIDTH,
    //   worldHeight: WORLD_HEIGHT,
    //   interaction: app.renderer.plugins.interaction
    // });
    // const resetViewport = () => {
    //   viewport.center = new PIXI.Point(WORLD_WIDTH / 2, WORLD_HEIGHT / 2);
    //   viewport.setZoom(0.5, true);
    // };
    // app.stage.addChild(viewport);
    // viewport
    //   .drag()
    //   .pinch()
    //   .wheel()
    //   .decelerate();
    // viewport.on('frame-end', () => {
    //   if (viewport.dirty) {
    //     requestRender();
    //     viewport.dirty = false;
    //   }
    // });
    
    // // create 4 layers: links, nodes, labels, front
    // const linksLayer = new PIXI.Graphics();
    // viewport.addChild(linksLayer);
    // const nodesLayer = new PIXI.Container();
    // viewport.addChild(nodesLayer);
    // const labelsLayer = new PIXI.Container();
    // viewport.addChild(labelsLayer);
    // const frontLayer = new PIXI.Container();
    // viewport.addChild(frontLayer);

    // // state
    // let nodeDataToNodeGfx = new WeakMap();
    // let nodeGfxToNodeData = new WeakMap();
    // let nodeDataToLabelGfx = new WeakMap();
    // let labelGfxToNodeData = new WeakMap();
    // let hoveredNodeData = undefined;
    // let hoveredNodeGfxOriginalChildren = undefined;
    // let hoveredLabelGfxOriginalChildren = undefined;
    // let clickedNodeData = undefined;

    // const updatePositions = async () => {
    //    // static force-directed layout, running in WebWorker thread
      

    //   linksLayer.clear();
    //   linksLayer.alpha = 0.6;
    //   let color = settings['link-color'];
    //   let opacity = 1 - settings['link-opacity'];
    //   let width = settings['link-width'];
    //   for (const link of links) {
    //     linksLayer.lineStyle(width, parseInt(color.replace(/^#/, ''), 16), opacity);
    //     linksLayer.moveTo(link.source.x, link.source.y);
    //     linksLayer.lineTo(link.target.x, link.target.y);
    //   }
    //   linksLayer.endFill();

    //   for (const node of nodes) {
    //     nodeDataToNodeGfx.get(node).position = new PIXI.Point(node.x, node.y)
    //     nodeDataToLabelGfx.get(node).position = new PIXI.Point(node.x, node.y)
    //   }
      
    //   requestRender();
    // };

    // // event handlers
    // const hoverNode = nodeData => {
    //   if (clickedNodeData) {
    //     return;
    //   }
    //   if (hoveredNodeData === nodeData) {
    //     return;
    //   }
      
    //   hoveredNodeData = nodeData;
      
    //   const nodeGfx = nodeDataToNodeGfx.get(nodeData);
    //   const labelGfx = nodeDataToLabelGfx.get(nodeData);

    //   // move to front layer
    //   nodesLayer.removeChild(nodeGfx);
    //   frontLayer.addChild(nodeGfx);
    //   labelsLayer.removeChild(labelGfx);
    //   frontLayer.addChild(labelGfx);
      
    //   // add hover effect
    //   hoveredNodeGfxOriginalChildren = [...nodeGfx.children];
    //   hoveredLabelGfxOriginalChildren = [...labelGfx.children];

    //   // circle border
    //   const circleBorder = new PIXI.Graphics();
    //   circleBorder.x = 0;
    //   circleBorder.y = 0;
    //   circleBorder.lineStyle(1.5, 0x000000);
    //   circleBorder.drawCircle(0, 0, NODE_RADIUS);
    //   nodeGfx.addChild(circleBorder);

    //   // text with background
    //   const labelText = new PIXI.Text(LABEL_TEXT(nodeData), {
    //     fontFamily: LABEL_FONT_FAMILY,
    //     fontSize: LABEL_FONT_SIZE,
    //     fill: 0x333333
    //   });
    //   labelText.x = 0;
    //   labelText.y = NODE_HIT_RADIUS + LABEL_Y_PADDING;
    //   labelText.anchor.set(0.5, 0);
    //   const labelBackground = new PIXI.Sprite(PIXI.Texture.WHITE);
    //   labelBackground.x = -(labelText.width + LABEL_X_PADDING * 2) / 2;
    //   labelBackground.y = NODE_HIT_RADIUS;
    //   labelBackground.width = labelText.width + LABEL_X_PADDING * 2;
    //   labelBackground.height = labelText.height + LABEL_Y_PADDING * 2;
    //   labelBackground.tint = 0xeeeeee;
    //   labelGfx.addChild(labelBackground);
    //   labelGfx.addChild(labelText);
      
    //   requestRender();
    // };
    // const unhoverNode = nodeData => {
    //   if (clickedNodeData) {
    //     return;
    //   }
    //   if (hoveredNodeData !== nodeData) {
    //     return;
    //   }
      
    //   hoveredNodeData = undefined;
      
    //   const nodeGfx = nodeDataToNodeGfx.get(nodeData);
    //   const labelGfx = nodeDataToLabelGfx.get(nodeData);
      
    //   // move back from front layer
    //   frontLayer.removeChild(nodeGfx);
    //   nodesLayer.addChild(nodeGfx);
    //   frontLayer.removeChild(labelGfx);
    //   labelsLayer.addChild(labelGfx);

    //   // clear hover effect
    //   const nodeGfxChildren = [...nodeGfx.children];
    //   for (let child of nodeGfxChildren) {
    //     if (!hoveredNodeGfxOriginalChildren.includes(child)) {
    //       nodeGfx.removeChild(child);
    //     }
    //   }
    //   hoveredNodeGfxOriginalChildren = undefined;
    //   const labelGfxChildren = [...labelGfx.children];
    //   for (let child of labelGfxChildren) {
    //     if (!hoveredLabelGfxOriginalChildren.includes(child)) {
    //       labelGfx.removeChild(child);
    //     }
    //   }
    //   hoveredLabelGfxOriginalChildren = undefined;
      
    //   requestRender();
    // };
    // const moveNode = (nodeData, point) => {
    //   const nodeGfx = nodeDataToNodeGfx.get(nodeData);
      
    //   nodeData.x = point.x;
    //   nodeData.y = point.y;
      
    //   updatePositions();
    // };
    // const appMouseMove = event => {
    //   if (!clickedNodeData) {
    //     return;
    //   }
      
    //   moveNode(clickedNodeData, viewport.toWorld(event.data.global));
    // };
    // const clickNode = nodeData => {
    //   clickedNodeData = nodeData;
      
    //   // enable node dragging
    //   app.renderer.plugins.interaction.on('mousemove', appMouseMove);
    //   // disable viewport dragging
    //   viewport.pause = true;
    // };
    // const unclickNode = () => {
    //   clickedNodeData = undefined;
      
    //   // disable node dragging
    //   app.renderer.plugins.interaction.off('mousemove', appMouseMove);
    //   // enable viewport dragging
    //   viewport.pause = false;
    // };
    

    // let defaultSize = settings['node-radius'];
    // let nodeSize = defaultSize, med = defaultSize, oldrng, min, max;
    // let sizeVariable = settings['node-radius-variable'];
    // if (sizeVariable !== 'None') {
    //   let n = session.network.nodes.length;
    //   min = Number.MAX_VALUE;
    //   max = Number.MIN_VALUE;
    //   for (let i = 0; i < n; i++) {
    //     let nodeSize = session.network.nodes[i][sizeVariable];
    //     if (typeof size == 'undefined') continue;
    //     if (nodeSize < min) min = nodeSize;
    //     if (nodeSize > max) max = nodeSize;
    //   }
    //   oldrng = max - min;
    //   med = oldrng / 2;
    // }

    // // create node graphics
    // const nodeDataGfxPairs = nodes.map(nodeData => {
    //   const nodeGfx = new PIXI.Container();
    //   nodeGfx.x = nodeData.x;
    //   nodeGfx.y = nodeData.y;
    //   nodeGfx.interactive = true;
    //   nodeGfx.buttonMode = true;
    //   nodeGfx.hitArea = new PIXI.Circle(0, 0, NODE_HIT_RADIUS);
    //   nodeGfx.on('mouseover', event => hoverNode(nodeGfxToNodeData.get(event.currentTarget)));
    //   nodeGfx.on('mouseout', event => unhoverNode(nodeGfxToNodeData.get(event.currentTarget)));
    //   nodeGfx.on('mousedown', event => clickNode(nodeGfxToNodeData.get(event.currentTarget)));
    //   nodeGfx.on('mouseup', () => unclickNode());
    //   nodeGfx.on('mouseupoutside', () => unclickNode());
      
    //   const circle = new PIXI.Graphics();
    //   circle.x = 0;
    //   circle.y = 0;
    //   let variable = settings['node-color-variable'];
    //   let fill = temp.style.nodeColorMap(nodeData[variable]);
    //   let alpha = temp.style.nodeAlphaMap(nodeData[variable]);
    //   circle.beginFill(parseInt(fill.replace(/^#/, ''), 16), parseInt(alpha));

    //   if (sizeVariable !== 'None') {
    //     nodeSize = d[sizeVariable];
    //     if (!isNumber(nodeSize)) nodeSize = med;
    //     nodeSize = (nodeSize - min) / oldrng;
    //     nodeSize = nodeSize * nodeSize * defaultSize + 100;
    //   }
    //   let nodeRadius = nodeSize/20;

    //   circle.drawCircle(0, 0, nodeRadius);
    //   nodeGfx.addChild(circle);
      
    //   const circleBorder = new PIXI.Graphics();
    //   circleBorder.lineStyle(1.5, 0xffffff);

    //   circleBorder.drawCircle(0, 0, nodeRadius);
    //   nodeGfx.addChild(circleBorder);

    //   // const icon = new PIXI.Text(ICON_TEXT, {
    //   //   fontFamily: ICON_FONT_FAMILY,
    //   //   fontSize: ICON_FONT_SIZE,
    //   //   fill: 0xffffff
    //   // });
    //   // icon.x = 0;
    //   // icon.y = 0;
    //   // icon.anchor.set(0.5);
    //   // nodeGfx.addChild(icon);
      
    //   const labelGfx = new PIXI.Container();
    //   labelGfx.x = nodeData.x;
    //   labelGfx.y = nodeData.y;
    //   labelGfx.interactive = true;
    //   labelGfx.buttonMode = true;
    //   labelGfx.on('mouseover', event => hoverNode(labelGfxToNodeData.get(event.currentTarget)));
    //   labelGfx.on('mouseout', event => unhoverNode(labelGfxToNodeData.get(event.currentTarget)));
    //   labelGfx.on('mousedown', event => clickNode(labelGfxToNodeData.get(event.currentTarget)));
    //   labelGfx.on('mouseup', () => unclickNode());
    //   labelGfx.on('mouseupoutside', () => unclickNode());
      
    //   const labelText = new PIXI.Text(LABEL_TEXT(nodeData), {
    //     fontFamily: LABEL_FONT_FAMILY,
    //     fontSize: LABEL_FONT_SIZE,
    //     fill: 0x333333
    //   });
    //   labelText.x = 0;
    //   labelText.y = NODE_HIT_RADIUS + LABEL_Y_PADDING;
    //   labelText.anchor.set(0.5, 0);
    //   const labelBackground = new PIXI.Sprite(PIXI.Texture.WHITE);
    //   labelBackground.x = -(labelText.width + LABEL_X_PADDING * 2) / 2;
    //   labelBackground.y = NODE_HIT_RADIUS;
    //   labelBackground.width = labelText.width + LABEL_X_PADDING * 2;
    //   labelBackground.height = labelText.height + LABEL_Y_PADDING * 2;
    //   labelBackground.tint = 0xffffff;
    //   labelBackground.alpha = 0.5;
    //   labelGfx.addChild(labelBackground);
    //   labelGfx.addChild(labelText);
      
    //   nodesLayer.addChild(nodeGfx);
    //   labelsLayer.addChild(labelGfx);

    //   return [nodeData, nodeGfx, labelGfx];
    // });

    // // create lookup tables
    // nodeDataToNodeGfx = new WeakMap(nodeDataGfxPairs.map(([nodeData, nodeGfx, labelGfx]) => [nodeData, nodeGfx]));
    // nodeGfxToNodeData = new WeakMap(nodeDataGfxPairs.map(([nodeData, nodeGfx, labelGfx]) => [nodeGfx, nodeData]));
    // nodeDataToLabelGfx = new WeakMap(nodeDataGfxPairs.map(([nodeData, nodeGfx, labelGfx]) => [nodeData, labelGfx]));
    // labelGfxToNodeData = new WeakMap(nodeDataGfxPairs.map(([nodeData, nodeGfx, labelGfx]) => [labelGfx, nodeData]));

    // // initial draw
    // resetViewport();
    // updatePositions();

    

    // // prevent body scrolling
    // app.view.addEventListener('wheel', event => { event.preventDefault(); });

    // document.getElementById('pixi').appendChild(app.view);


    // $('#network-settings-toggle').on('click', function () {
    //   let pane = $('#network-settings-pane');
    //   if ($(this).hasClass('active')) {
    //     pane.animate({ left: '-400px' }, function () { pane.hide(); });
    //   } else {
    //     pane.show(0, function () { pane.animate({ left: '0px' }); });
    //   }
    // });


    // $('#node-radius-variable').on('change', function () {
    //   settings['node-radius-variable'] = this.value;
    //   updateNodes();
    // });

    // let isNumber = a => typeof a == "number";

    // function updateNodes() {
    //   let defaultSize = settings['node-radius'];
    //   let nodeSize = defaultSize, med = defaultSize, oldrng, min, max;
    //   let sizeVariable = settings['node-radius-variable'];
    //   if (sizeVariable !== 'None') {
    //     let n = session.network.nodes.length;
    //     min = Number.MAX_VALUE;
    //     max = Number.MIN_VALUE;
    //     for (let i = 0; i < n; i++) {
    //       let nodeSize = session.network.nodes[i][sizeVariable];
    //       if (typeof nodeSize == 'undefined') continue;
    //       if (nodeSize < min) min = nodeSize;
    //       if (nodeSize > max) max = nodeSize;
    //     }
    //     oldrng = max - min;
    //     med = oldrng / 2;
    //   }

    //   let variable = settings['node-color-variable'];
    //   for (const node of nodes) {
    //     // console.log('node', node, 'GFX', nodeDataToNodeGfx.get(node))
    //     nodeDataToNodeGfx.get(node).children[0].clear();
    //     nodeDataToNodeGfx.get(node).children[1].clear();
    //     if (variable == 'None') {
    //         let fill = settings['node-color'];
    //         // nodes.attr('fill', col).attr('opacity', 1);
    //         nodeDataToNodeGfx.get(node).children[0].beginFill(parseInt(fill.replace(/^#/, ''), 16), 1);
    //     } else {
    //       let fill = temp.style.nodeColorMap(node[variable]);
    //       let alpha = temp.style.nodeAlphaMap(node[variable]);
    //       nodeDataToNodeGfx.get(node).children[0].beginFill(parseInt(fill.replace(/^#/, ''), 16), parseInt(alpha));
        
    //     }

    //     if (sizeVariable !== 'None') {
    //       nodeSize = node[sizeVariable];
    //       if (!isNumber(nodeSize)) 
    //         nodeSize = med;
    //       nodeSize = (nodeSize - min) / oldrng;
    //       nodeSize = nodeSize * nodeSize * nodeSize * defaultSize + 100;
    //     }

    //     let radius = nodeSize/20;
        
    //     nodeDataToNodeGfx.get(node).children[0].drawCircle(0, 0, radius);
    //     nodeDataToNodeGfx.get(node).children[1].lineStyle(1.5, 0xffffff);
    //     nodeDataToNodeGfx.get(node).children[1].drawCircle(0, 0, radius);
    //   }
    //   requestRender();
    // }




    // $window.on('node-color-change', updateNodes)


  })();
</script>
